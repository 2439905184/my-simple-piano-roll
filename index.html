<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PianoRoll Demo</title>
</head>
<body>
    <div>
        吸附单位选择
        <button onclick="change_grid('all')">全音符</button>
        <button onclick="change_grid('two')">2分</button>
        <button onclick="change_grid('four')">4分</button>
        <button onclick="change_grid('eight')">8分</button>
        <button onclick="change_grid('sixteen')">16分</button>
        拉伸音符<input type="checkbox" onchange="changeStretch(this)">
        <!-- <button onclick="addPattern(this)">创建新旋律片段+</button> -->
        <button onclick="delSelPattern()">清空选中的旋律片段</button>
        <button onclick="delSelNote()">删除选中的音符</button>
    </div>
    <div id="pattern-list" style="width: 800px;overflow-y: auto;white-space: nowrap;">
        旋律片段
    </div>
    <canvas id="piano-roll" width="864" height="384"></canvas>
    <canvas id="vertical-scrollbar" width="20" height="384"></canvas>
    <script>
        // todo：完成项目后换成testPlugin()这种风格命名变量和函数
        const PatternList = document.getElementById('pattern-list');//uiPatternList
        var pattern = []
        var selPatternIndex = -1
        const HANDLE_WIDTH = 8 // 拉伸手柄的宽度
        var isNoteStretch = false
        var isMouseDown = false
        var isStretching = false
        document.addEventListener('contextmenu',function(e)
        {
            e.preventDefault();
        })
        const canvas = document.getElementById('piano-roll');
        const scrollbarCanvas = document.getElementById('vertical-scrollbar');
        const scrollbarCtx = scrollbarCanvas.getContext('2d');
        const scrollbarSliderHeight = 20
        var scrollbarUiData = {
            "y":0,
            "isMouseDown":false
        }
        CanvasRenderingContext2D.prototype.drawLine = function(x1, y1, x2, y2) 
        {
            this.beginPath();
            this.moveTo(x1, y1);
            this.lineTo(x2, y2);
            this.stroke();
        };
        const Color = {
            "black": "#000000",
            "white": "#ffffff",
            "grey": "#808080",
            "green":"#008000"
        }
        const ctx = canvas.getContext('2d');
        var selectedNoteIndex = -1;
        const all_note_width = 800
        const note_height = 32 // 重构为grid_size = {"width","height"}
        var dragOffsetX = 0
        var dragOffsetY = 0

        var mouseDownX = 0
        var mouseDownY = 0
        // 要绘制的音符宽度
        var note_width = all_note_width
        var grid = 16
        // 每个小节的音符序列
        var seq = []
        /*seq
        {
            "x":0,
            "y":0,
            "width":0,
        }
        */
        //一个音阶，0表示白键，1表示黑键
        const melody_scale = [0,1,0,1,0,0,1,0,1,0,1,0]
        const keyWidth = 64;
        function initUI()
        {
            for(var i = 0; i < 512; i++)
            {
                addPattern(i)
            }
            selPattern(PatternList.children[0])
            redraw();
        }
        initUI()
        function snap(value,grid_space)
        {
            return Math.floor(value / grid_space) * grid_space;
        }
        function redrawKey()
        {
            for(var i = 0; i < melody_scale.length; i++)
            {
                var canvasY = musicToCanvasY(i*note_height)
                if(melody_scale[i] == 0)
                {
                    ctx.fillStyle = Color.white
                }
                else{
                    ctx.fillStyle = Color.black
                }
                ctx.fillRect(0, canvasY, keyWidth, note_height)
                ctx.strokeRect(0, canvasY, keyWidth, note_height)
            }
            ctx.fillStyle = Color.black
            ctx.font = "20px Arial"
            var textY = canvasY + note_height / 2
            ctx.fillText("C4", keyWidth-ctx.measureText("C4").width, canvas.height);
        }
        function redrawGrid()
        {
            //这里应该从下往上绘制
            for(var i = 0; i < melody_scale.length; i++)
            {
                var canvasY = musicToCanvasY(i*note_height)
                if(melody_scale[i] == 0)
                {
                    ctx.fillStyle = Color.white
                }
                else{
                    ctx.fillStyle = Color.grey
                }
                ctx.fillRect(keyWidth, canvasY, canvas.width-keyWidth, note_height)
            }
            ctx.fillStyle = (0,0,canvas.width,canvas.height)
            ctx.fillStyle = "#000000"
            ctx.lineWidth = 1
                    // 绘制垂直网格线
            const gridSpacing = all_note_width / grid;
            for (let i = 0; i <= grid; i++) {
                const x = i * gridSpacing + keyWidth;
                ctx.drawLine(x, 0, x, canvas.height);
            }
                // 绘制水平线（钢琴键）
            for (let i = 0; i <= canvas.height / note_height; i++) {
                const y = i * note_height;
                ctx.drawLine(keyWidth, y, canvas.width, y);
            }
        }
        function redrawScrollbar()
        {
            scrollbarCtx.clearRect(0, 0, scrollbarCanvas.width, scrollbarCanvas.height);
            scrollbarCtx.fillStyle = Color.black;
            scrollbarCtx.fillRect(0, 0, scrollbarCanvas.width, scrollbarCanvas.height);
            scrollbarCtx.fillStyle = Color.green;
            scrollbarCtx.fillRect(0, scrollbarUiData.y, scrollbarCanvas.width, scrollbarSliderHeight);   
        }
        function redraw()
        {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            redrawGrid()
            redrawKey()
            redrawScrollbar()
            for(var i = 0; i < seq.length; i++)
            {
                var noteX = seq[i].x + keyWidth
                if(selectedNoteIndex == i)
                {
                    ctx.fillStyle = "#00ff00"
                }
                else{
                    ctx.fillStyle = "#ff0000"
                }
                ctx.fillRect(noteX, seq[i].y, seq[i].width, seq[i].height)
                if(isNoteStretch && selectedNoteIndex ==i)
                {
                    ctx.fillStyle = "#008800"
                    ctx.fillRect(noteX + seq[i].width - HANDLE_WIDTH/2, 
                         seq[i].y + 2, 
                         HANDLE_WIDTH, 
                         seq[i].height - 4);
                }
            }
            
        }
        function hitTest(x,y)
        {
            var gridX = x - keyWidth
            if(x< keyWidth)
            {
                return { hit: false, index: -1, note: null };
            }
            // 如果启用了拉伸且有选中的音符，优先检查是否点击在手柄上
            if (isNoteStretch && selectedNoteIndex >= 0) {
                const note = seq[selectedNoteIndex];
                var noteScreenX = note.x + keyWidth
                // 检查是否点击在拉伸手柄上
                if (x >= noteScreenX + note.width - HANDLE_WIDTH/2 && 
                    x <= noteScreenX + note.width + HANDLE_WIDTH/2 &&
                    y >= note.y && 
                    y <= note.y + note.height) {
                    // 点击在手柄上，不处理为音符点击
                    return { hit: false, index: -1, note: null };
                }
            }
            // 从后往前检查，因为后绘制的音符在视觉上在顶层
            for (let i = seq.length - 1; i >= 0; i--) 
            {
                const note = seq[i];
                var noteScreenX = note.x + keyWidth
                // 检查点是否在矩形区域内
                if (x >= noteScreenX && x <= noteScreenX + note.width && y >= note.y && y <= note.y + note.height) 
                {
                    return { hit: true, index: i, note: note };
                }
            }
            return { hit: false, index: -1, note: null };
        }
        function hitTestHandle(x,y)
        {
            if(!isNoteStretch || selectedNoteIndex < 0)
            {
                return false;
            }
            const note = seq[selectedNoteIndex];
            var noteScreenX = note.x + keyWidth;
            if (x >= noteScreenX + note.width - HANDLE_WIDTH/2 &&  x <= noteScreenX + note.width + HANDLE_WIDTH/2 &&y >= note.y && y <= note.y + note.height) 
            {
                return true;
            }
            return false;
        }
        //绿色手指
        function hitTestVScrollbarSlider(x,y)
        {
            if (y >= scrollbarUiData.y && y <= scrollbarUiData.y + scrollbarSliderHeight) 
            {scrollbarUiData.isMouseDown = true}
            else{
                return false;
            }
        }
        function delSelNote()
        {
            if(selectedNoteIndex >= 0)
            {
                seq.splice(selectedNoteIndex, 1);
                selectedNoteIndex = -1
                console.log(seq)
                pattern[selPatternIndex].seq = [...seq]
            }
            redraw()
        }
        canvas.addEventListener('mousedown', function(e) 
        {
            isMouseDown = true
            isStretching = false
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            mouseDownX = x
            mouseDownY = y
            var gridX = x -keyWidth
            if(isNoteStretch && selectedNoteIndex>=0 && hitTestHandle(x,y))
            {
                isStretching = true
                //dragOffsetX = x - (seq[selectedNoteIndex].x + seq[selectedNoteIndex].width);
                dragOffsetX = gridX - (seq[selectedNoteIndex].x + seq[selectedNoteIndex].width);
                return
            }
            // 检测按下的地方是否在音符内
            var hitResult = hitTest(x, y);
            if(hitResult && hitResult.hit)
            {
                selectedNoteIndex = hitResult.index
                // dragOffsetX = x - seq[selectedNoteIndex].x
                dragOffsetX = gridX - seq[selectedNoteIndex].x
                dragOffsetY = y - seq[selectedNoteIndex].y
            }
            else{
                selectedNoteIndex = -1
                
                if(x >= keyWidth && x < canvas.width)
                {
                    var grid_space = all_note_width / grid
                    seq.push({
                    "x":snap(gridX,grid_space),
                    "y":snap(y,note_height),
                    "width":grid_space,
                    "height":note_height
                })
                pattern[selPatternIndex].seq = [...seq]
                }
            }
            redraw();
        });
        canvas.addEventListener('mousemove', function(e) 
        {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            var gridX = x - keyWidth
            if(selectedNoteIndex >= 0 && isMouseDown)
            {
                var gridSpace = all_note_width / grid
                if(isStretching)
                {
                    //var newWidth = x - seq[selectedNoteIndex].x + dragOffsetX
                    var newWidth = gridX - seq[selectedNoteIndex].x + dragOffsetX;
                    // 确保音符宽度至少为一个网格单位
                    //newWidth = Math.max(gridSpace, snap(newWidth, gridSpace));
                    var maxX = canvas.width;
                    // 应用捕捉并限制在有效范围内
                    newWidth = Math.max(
                        gridSpace, 
                        Math.min(
                            maxX - seq[selectedNoteIndex].x, 
                            Math.round(newWidth / gridSpace) * gridSpace
                        )
                    );
                    seq[selectedNoteIndex].width = newWidth;
                    pattern[selPatternIndex].seq = [...seq]
                    redraw();
                }
                else{
                    // 处理音符移动
                    //var adjustedX = x - dragOffsetX
                    var adjustedX = gridX - dragOffsetX
                    var adjustedY = y - dragOffsetY
                    if(adjustedX < 0)
                    {
                        adjustedX = 0
                    }
                    if(adjustedY < 0)
                    {
                        adjustedY = 0
                    }
                    //这里需要防止音符超出右侧画布
                    /*if(adjustedX + seq[selectedNoteIndex].width > canvas.width)
                    {
                        seq[selectedNoteIndex].x = canvas.width - seq[selectedNoteIndex].width
                    }*/
                    seq[selectedNoteIndex].x = snap(adjustedX,gridSpace)
                    seq[selectedNoteIndex].y = snap(adjustedY,note_height)
                    pattern[selPatternIndex].seq = [...seq]
                    redraw();
                }
            }
            // console.log(isMouseDown)
        })
        canvas.addEventListener('mouseup', function(e) 
        {
            isMouseDown = false
            isStretching = false
            redraw()
        });
        function clamp(value,min,max)
        {
            return Math.min(Math.max(value,min),max)
        }
        scrollbarCanvas.addEventListener('mousedown', function(e) 
        {
            const rect = scrollbarCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            scrollbarUiData.isMouseDown = true;
            if (y >= scrollbarUiData.y && y <= scrollbarUiData.y + scrollbarSliderHeight) 
            {
                // 记录点击位置相对于拇指顶部的偏移
                scrollbarUiData.dragOffset = y - scrollbarUiData.y;
            } else {
                // 点击在滚动条轨道上，直接跳转到该位置
                scrollbarUiData.y = clamp(y - scrollbarSliderHeight / 2, 0, scrollbarCanvas.height - scrollbarSliderHeight);
                scrollbarUiData.dragOffset = scrollbarSliderHeight / 2;
            }
            redrawScrollbar()
        })
        scrollbarCanvas.addEventListener('mouseup', function(e) 
        {
            scrollbarUiData.isMouseDown = false
        })
        scrollbarCanvas.addEventListener('mousemove', function(e) 
        {
            const rect = scrollbarCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (scrollbarUiData.isMouseDown) {
                const rect = scrollbarCanvas.getBoundingClientRect();
                const y = e.clientY - rect.top;
                
                // 根据拖拽偏移计算新的拇指位置
                scrollbarUiData.y = clamp(y - scrollbarUiData.dragOffset, 0, scrollbarCanvas.height - scrollbarSliderHeight);
                
                redrawScrollbar();
            }
        })
        scrollbarCanvas.addEventListener('mouseleave',function(e)
        {
            scrollbarUiData.isMouseDown = false
        })
        function change_grid(type)
        {
            switch(type)
            {
                case 'all':
                    note_width = all_note_width
                    grid=1
                    break;
                case 'two':
                    note_width = all_note_width / 2
                    grid=2
                    break;
                case 'four':
                    note_width = all_note_width / 4
                    grid=4
                    break;
                case 'eight':
                    note_width = all_note_width / 8
                    grid=8
                    break;
                case "sixteen":
                    note_width = all_note_width / 16
                    grid=16
                    break;
            }
            if(selPatternIndex >=0 && pattern[selPatternIndex])
            {
                pattern[selPatternIndex].grid = grid
            }
            redraw()
        }
        function changeStretch(checkbox)
        {
            isNoteStretch = checkbox.checked
            //console.log(isNoteStretch)
        }
        function addPattern(self)
        {
            pattern.push({
                "grid":16,
                "seq":[]
            })
            var btn = document.createElement('button')
            btn.innerHTML = pattern.length
            btn.onclick = function(){selPattern(btn)}
            PatternList.appendChild(btn)
        }
        function delSelPattern()
        {
            seq = []
            pattern[selPatternIndex].seq = [];
            redraw()
        }
        function selPattern(self)
        {
            for(var i=0;i<PatternList.children.length;i++)
            {
                PatternList.children[i].style = ""
            }
            self.style = "background-color: orange;"
            selPatternIndex = self.innerHTML -1
            if(pattern[selPatternIndex] && pattern[selPatternIndex].grid !=undefined )
            {
                grid = pattern[selPatternIndex].grid
            }
            if(pattern[selPatternIndex] && pattern[selPatternIndex].seq)
            {
                seq = [...pattern[selPatternIndex].seq];
            }
            else{
                seq = []
            }
            redraw()
        }
        // 把音符序序列的宽度转换为音符单位
        function convertSeqMusicStyle()
        {

        }
        // 修改绘制函数，将音乐坐标转换为Canvas坐标
        function musicToCanvasY(musicY) 
        {
            // musicY: 音乐坐标（低音=0，高音=大值）
            // canvas.height: Canvas总高度
            // note_height: 每个音符的高度
            return canvas.height - musicY - note_height;
        }
    </script>
</body>
</html>